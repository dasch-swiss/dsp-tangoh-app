{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Knora Ontologies Knora APIs Publishing and Deployment Knora Internals Salsah Sipi Lucene Frequently Asked Questions Release Notes","title":"Home"},{"location":"01-introduction/","text":"Introduction What Is Knora? Data Formats in Knora Standoff/RDF Text Markup An Example Project","title":"Index"},{"location":"01-introduction/#introduction","text":"What Is Knora? Data Formats in Knora Standoff/RDF Text Markup An Example Project","title":"Introduction"},{"location":"01-introduction/data-formats/","text":"Data Formats in Knora As explained in What Is Knora? , Knora stores data in a small number of formats that are suitable for long-term preservation while facilitating data reuse. The following is a non-exhaustive list of data formats and how their content can be stored and managed by Knora: Original Format Format in Knora Text (XML, LaTeX, Microsoft Word, etc.) Knora resources (RDF) containing Standoff/RDF Tabular data, including relational databases Knora resources Data in tree or graph structures Knora resources Images (JPEG, PNG, etc.) JPEG 2000 files stored by Sipi Audio and video files Audio and video files stored by Sipi (in archival formats to be determined) PDF Can be stored by Sipi, but data reuse is improved by extracting the text for storage as Standoff/RDF","title":"Data Formats in Knora"},{"location":"01-introduction/data-formats/#data-formats-in-knora","text":"As explained in What Is Knora? , Knora stores data in a small number of formats that are suitable for long-term preservation while facilitating data reuse. The following is a non-exhaustive list of data formats and how their content can be stored and managed by Knora: Original Format Format in Knora Text (XML, LaTeX, Microsoft Word, etc.) Knora resources (RDF) containing Standoff/RDF Tabular data, including relational databases Knora resources Data in tree or graph structures Knora resources Images (JPEG, PNG, etc.) JPEG 2000 files stored by Sipi Audio and video files Audio and video files stored by Sipi (in archival formats to be determined) PDF Can be stored by Sipi, but data reuse is improved by extracting the text for storage as Standoff/RDF","title":"Data Formats in Knora"},{"location":"01-introduction/example-project/","text":"An Example Project This section introduces some of the basic concepts involved in creating ontologies for Knora projects, by means of a relatively simple example project. Before reading this document, it will be helpful to have some familiarity with the basic concepts explained in knora-base. Knora comes with two example projects, called incunabula and images-demo . Here we will consider the incunabula example, which is a reduced version of a real research project on early printed books. It is designed to store an image of each page of each book, as well as RDF data about books, pages, their contents, and relationships between them. At the moment, only the RDF data is provided in the example project, not the images. The incunabula ontology is in the file incunabula-onto.ttl , and its data is in the file incunabula-demo-data.ttl . Both these files are in a standard RDF file format called Turtle . The Knora distribution includes sample scripts (in the webapi/scripts directory) for importing these files directly into different triplestores. If you are starting a new project from scratch, you can adapt these scripts to import your ontology (and any existing RDF data) into your triplestore for use with Knora. The syntax of Turtle is fairly simple: it is basically a sequence of triples. We will consider some details of Turtle syntax as we go along. The Incunabula Ontology Here we will just focus on some of the main aspects of the ontology. An ontology file typically begins by defining prefixes for the IRIs of other ontologies that will be referred to. First there are some prefixes for ontologies that are very commonly used in RDF: @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> . @prefix owl: <http://www.w3.org/2002/07/owl#> . @prefix xsd: <http://www.w3.org/2001/XMLSchema#> . @prefix foaf: <http://xmlns.com/foaf/0.1/> . @prefix dcterms: <http://purl.org/dc/terms/> . The rdf , rdfs , and owl ontologies contain basic properties that are used to define ontology entities. The xsd ontology contains definitions of literal data types such as string and integer . (For more information about these ontologies, see the references in knora-base.) The foaf ontology contains classes and properties for representing people. The dcterms ontology represents Dublin Core metadata. Then we define prefixes for Knora ontologies: @prefix knora-base: <http://www.knora.org/ontology/knora-base#> . @prefix salsah-gui: <http://www.knora.org/ontology/salsah-gui#> . The knora-base ontology contains Knora's core abstractions, and is described in knora-base. The salsah-gui ontology includes properties that Knora projects must use to enable SALSAH, Knora's generic virtual research environment. For convenience, we can use the empty prefix to refer to the incunabula ontology itself: @prefix : <http://www.knora.org/ontology/0803/incunabula#> . However, outside the ontology file, it would make more sense to define an incunabula prefix to refer to the incunabula ontology. Properties All the content produced by a Knora project must be stored in Knora resources (see incunabula-resource-classes). Resources have properties that point to different parts of their contents; for example, the incunabula project contains books, which have properties like title . Every property that poitns to a Knora value must be a subproperty of knora-base:hasValue , and every property that points to another Knora resource must be a subproperty of knora-base:hasLinkTo . Here is the definition of the incunabula:title property: :title rdf:type owl:ObjectProperty ; rdfs:subPropertyOf knora-base:hasValue, dcterms:title ; rdfs:label \"Titel\"@de , \"Titre\"@fr , \"Titolo\"@it , \"Title\"@en ; knora-base:subjectClassConstraint :book ; knora-base:objectClassConstraint knora-base:TextValue ; salsah-gui:guiElement salsah-gui:SimpleText ; salsah-gui:guiAttribute \"size=80\" , \"maxlength=255\" . The definition of incunabula:title consists of a list of triples, all of which have :title as their subject. To avoid repeating :title for each triple, Turtle syntax allows us to use a semicolon ( ; ) to separate triples that have the same subject. Moreover, some triples also have the same predicate; a comma ( , ) is used to avoid repeating the predicate. The definition of :title says: rdf:type owl:ObjectProperty : It is an owl:ObjectProperty . There are two kinds of OWL properties: object properties and datatype properties. Object properties point to objects, which have IRIs and can have their own properties. Datatype properties point to literal values, such as strings and integers. rdfs:subPropertyOf knora-base:hasValue, dcterms:title : It is a subproperty of knora-base:hasValue and dcterms:title . Since the objects of this property will be Knora values, it must be a subproperty of knora-base:hasValue . To facilitate searches, we have also chosen to make it a subproperty of dcterms:title . In the Knora API v2, if you do a search for resources that have a certain dcterms:title , and there is a resource with a matching incunabula:title , the search results could include that resource. rdfs:label \"Titel\"@de , etc.: It has the specified labels in various languages. These are needed, for example, by user interfaces, to prompt the user to enter a value. knora-base:subjectClassConstraint :book : The subject of the property must be an incunabula:book . knora-base:objectClassConstraint knora-base:TextValue : The object of this property must be a knora-base:TextValue (which is a subclass of knora-base:Value ). salsah-gui:guiElement salsah-gui:SimpleText : When SALSAH asks a user to enter a value for this property, it should use a simple text field. salsah-gui:guiAttribute \"size=80\" , \"maxlength=255\" : The SALSAH text field for entering a value for this property should be 80 characters wide, and should accept at most 255 characters. The incunabula ontology contains several other property definitions that are basically similar. Note that different subclasses of Value are used. For example, incunabula:pubdate , which represents the publication date of a book, points to a knora-base:DateValue . The DateValue class stores a date range, with a specified degree of precision and a preferred calendar system for display. A property can point to a Knora resource instead of to a Knora value. For example, in the incunabula ontology, there are resources representing pages and books, and each page is part of some book. This relationship is expressed using the property incunabula:partOf : :partOf rdf:type owl:ObjectProperty ; rdfs:subPropertyOf knora-base:isPartOf ; rdfs:label \"ist ein Teil von\"@de , \"est un part de\"@fr , \"e una parte di\"@it , \"is a part of\"@en ; rdfs:comment \"\"\"Diese Property bezeichnet eine Verbindung zu einer anderen Resource, in dem ausgesagt wird, dass die vorliegende Resource ein integraler Teil der anderen Resource ist. Zum Beispiel ist eine Buchseite ein integraler Bestandteil genau eines Buches.\"\"\"@de ; knora-base:subjectClassConstraint :page ; knora-base:objectClassConstraint :book ; salsah-gui:guiElement salsah-gui:Searchbox . The key things to notice here are: rdfs:subPropertyOf knora-base:isPartOf : The Knora base ontology provides a generic isPartOf property to express part-whole relationships. Like many properties defined in knora-base , a project cannot use knora-base:isPartOf directly, but must make a subproperty such as incunabula:partOf . It is important to note that knora-base:isPartOf is a subproperty of knora-base:hasLinkTo . Any property that points to a knora-base:Resource must be a subproperty of knora-base:hasLinkTo . In Knora terminology, such a property is called a link property . knora-base:objectClassConstraint :book : The object of this property must be a member of the class incunabula:book , which, as we will see below, is a subclass of knora-base:Resource . salsah-gui:guiElement salsah-gui:Searchbox : When SALSAH prompts a user to select the book that a page is part of, it should provide a search box enabling the user to find the desired book. Because incunabula:partOf is a link property, it must always accompanied by a link value property , which enables Knora to store metadata about each link that is created with the link property. This metadata includes the date and time when the link was created, its owner, the permissions it grants, and whether it has been deleted. Storing this metadata allows Knora to authorise users to see or modify the link, as well as to query a previous state of a repository in which a deleted link had not yet been deleted. (The ability to query previous states of a repository is planned for Knora API version 2.) The name of a link property and its link value property must be related by the following naming convention: to determine the name of the link value property, add the word Value to the name of the link property. Hence, the incunabula ontology defines the property partOfValue : :partOfValue rdf:type owl:ObjectProperty ; rdfs:subPropertyOf knora-base:isPartOfValue ; knora-base:subjectClassConstraint :page ; knora-base:objectClassConstraint knora-base:LinkValue . As a link value property, incunabula:partOfValue must point to a knora-base:LinkValue . The LinkValue class is an RDF reification of a triple (in this case, the triple that links a page to a book). For more details about this, see knora-base-linkvalue. Note that the property incunabula:hasAuthor points to a knora-base:TextValue , because the incunabula project represents authors simply by their names. A more complex project could represent each author as a resource, in which case incunabula:hasAuthor would need to be a subproperty of knora-base:hasLinkTo . Resource Classes The two main resource classes in the incunabula ontology are book and page . Here is incunabula:book : :book rdf:type owl:Class ; rdfs:subClassOf knora-base:Resource , [ rdf:type owl:Restriction ; owl:onProperty :title ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :hasAuthor ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :publisher ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"3\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :publoc ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"4\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :pubdate ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :location ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"6\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :url ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"7\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :description ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :physical_desc ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"9\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :note ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :citation ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :book_comment ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"12\"^^xsd:nonNegativeInteger ] ; knora-base:resourceIcon \"book.gif\" ; rdfs:label \"Buch\"@de , \"Livre\"@fr , \"Libro\"@it , \"Book\"@en ; rdfs:comment \"\"\"Diese Resource-Klasse beschreibt ein Buch\"\"\"@de . Like every Knora resource class, incunabula:book is a subclass of knora-base:Resource . It is also a subclass of a number of other classes of type owl:Restriction , which are defined in square brackets, using Turtle's syntax for anonymous blank nodes. Each owl:Restriction specifies a cardinality for a property that is allowed in resources of type incunabula:book . A cardinality is indeed a kind of restriction: it means that a resource of this type may have, or must have, a certain number of instances of the specified property. For example, incunabula:book has cardinalities saying that a book must have at least one title and at most one publication date. In the Knora API version 1, the word 'occurrence' is used instead of 'cardinality'. The OWL cardinalities supported by Knora are described in OWL Cardinalities . Note that incunabula:book specifies a cardinality of owl:minCardinality 0 on the property incunabula:hasAuthor . At first glance, this might seem as if it serves no purpose, since it says that the property is optional and can have any number of instances. You may be wondering whether this cardinality could simply be omitted from the definition of incunabula:book . However, Knora requires every property of a resource to have some cardinality in the resource's class. This is because Knora uses the cardinalities to determine which properties are possible for instances of the class, and the Knora API relies on this information. If there was no cardinality for incunabula:hasAuthor , Knora would not allow a book to have an author. Each owl:Restriction specifying a cardinality can include the predicate salsah-gui:guiOrder , which tells the SALSAH GUI the order the properties should be displayed in. Here is the definition of incunabula:page : :page rdf:type owl:Class ; rdfs:subClassOf knora-base:StillImageRepresentation , [ rdf:type owl:Restriction ; owl:onProperty :pagenum ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :partOfValue ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :partOf ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :seqnum ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"3\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :description ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :citation ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :page_comment ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"6\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :origname ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"7\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :hasLeftSidebandValue ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :hasLeftSideband ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :hasRightSidebandValue ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"11\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :hasRightSideband ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"11\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :transcription ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"12\"^^xsd:nonNegativeInteger ] ; knora-base:resourceIcon \"page.gif\" ; rdfs:label \"Seite\"@de , \"Page\"@fr , \"Page\"@en ; rdfs:comment \"\"\"Eine Seite ist ein Teil eines Buchs\"\"\"@de , \"\"\"Une page est une partie d'un livre\"\"\"@fr , \"\"\"A page is a part of a book\"\"\"@en . The incunabula:page class is a subclass of knora-base:StillImageRepresentation , which is a subclass of knora-base:Representation , which is a subclass of knora-base:Resource . The class knora-base:Representation is used for resources that contain metadata about files stored by Knora. Each It has different subclasses that can hold different types of files, including still images, audio, and video files. A given Representation can store metadata about several different files, as long as they are of the same type and are semantically equivalent, e.g. are different versions of the same image with different colorspaces, so that coordinates in one file will work in the other files. In Knora, a subclass inherits the cardinalities defined in its superclasses. Let's look at the class hierarchy of incunabula:page , starting with knora-base:Representation : :Representation rdf:type owl:Class ; rdfs:subClassOf :Resource , [ rdf:type owl:Restriction ; owl:onProperty :hasFileValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:comment \"A resource that can store one or more FileValues\"@en . This says that a Representation must have at least one instance of the property hasFileValue , which is defined like this: :hasFileValue rdf:type owl:ObjectProperty ; rdfs:subPropertyOf :hasValue ; :subjectClassConstraint :Representation ; :objectClassConstraint :FileValue . The subject of hasFileValue must be a Representation , and its object must be a FileValue . There are different subclasses of FileValue for different kinds of files, but we'll skip the details here. This is the definition of knora-base:StillImageRepresentation : :StillImageRepresentation rdf:type owl:Class ; rdfs:subClassOf :Representation , [ rdf:type owl:Restriction ; owl:onProperty :hasStillImageFileValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:comment \"A resource that can contain two-dimensional still image files\"@en . It must have at least one instance of the property hasStillImageFileValue , which is defined as follows: :hasStillImageFileValue rdf:type owl:ObjectProperty ; rdfs:subPropertyOf :hasFileValue ; :subjectClassConstraint :StillImageRepresentation ; :objectClassConstraint :StillImageFileValue . Because hasStillImageFileValue is a subproperty of hasFileValue , the cardinality on hasStillImageFileValue , defined in the subclass StillImageRepresentation , overrides the cardinality on hasFileValue , defined in the superclass Representation . In other words, the more general cardinality in the superclass is replaced by a more specific cardinality in the base class. Since incunabula:page is a subclass of StillImageRepresentation , it inherits the cardinality on hasStillImageFileValue . As a result, a page must have at least one image file attached to it. Here's another example of cardinality inheritance. The class knora-base:Resource has a cardinality for knora-base:seqnum . The idea is that resources of any type could be arranged in some sort of sequence. As we saw above, incunabula:page is a subclass of knora-base:Resource . But incunabula:page has its own cardinality for incunabula:seqnum , which is a subproperty of knora-base:seqnum . Once again, the subclass's cardinality on the subproperty replaces the superclass's cardinality on the superproperty: a page is allowed to have an incunabula:seqnum , but it is not allowed to have a knora-base:seqnum .","title":"An Example Project"},{"location":"01-introduction/example-project/#an-example-project","text":"This section introduces some of the basic concepts involved in creating ontologies for Knora projects, by means of a relatively simple example project. Before reading this document, it will be helpful to have some familiarity with the basic concepts explained in knora-base. Knora comes with two example projects, called incunabula and images-demo . Here we will consider the incunabula example, which is a reduced version of a real research project on early printed books. It is designed to store an image of each page of each book, as well as RDF data about books, pages, their contents, and relationships between them. At the moment, only the RDF data is provided in the example project, not the images. The incunabula ontology is in the file incunabula-onto.ttl , and its data is in the file incunabula-demo-data.ttl . Both these files are in a standard RDF file format called Turtle . The Knora distribution includes sample scripts (in the webapi/scripts directory) for importing these files directly into different triplestores. If you are starting a new project from scratch, you can adapt these scripts to import your ontology (and any existing RDF data) into your triplestore for use with Knora. The syntax of Turtle is fairly simple: it is basically a sequence of triples. We will consider some details of Turtle syntax as we go along.","title":"An Example Project"},{"location":"01-introduction/example-project/#the-incunabula-ontology","text":"Here we will just focus on some of the main aspects of the ontology. An ontology file typically begins by defining prefixes for the IRIs of other ontologies that will be referred to. First there are some prefixes for ontologies that are very commonly used in RDF: @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> . @prefix owl: <http://www.w3.org/2002/07/owl#> . @prefix xsd: <http://www.w3.org/2001/XMLSchema#> . @prefix foaf: <http://xmlns.com/foaf/0.1/> . @prefix dcterms: <http://purl.org/dc/terms/> . The rdf , rdfs , and owl ontologies contain basic properties that are used to define ontology entities. The xsd ontology contains definitions of literal data types such as string and integer . (For more information about these ontologies, see the references in knora-base.) The foaf ontology contains classes and properties for representing people. The dcterms ontology represents Dublin Core metadata. Then we define prefixes for Knora ontologies: @prefix knora-base: <http://www.knora.org/ontology/knora-base#> . @prefix salsah-gui: <http://www.knora.org/ontology/salsah-gui#> . The knora-base ontology contains Knora's core abstractions, and is described in knora-base. The salsah-gui ontology includes properties that Knora projects must use to enable SALSAH, Knora's generic virtual research environment. For convenience, we can use the empty prefix to refer to the incunabula ontology itself: @prefix : <http://www.knora.org/ontology/0803/incunabula#> . However, outside the ontology file, it would make more sense to define an incunabula prefix to refer to the incunabula ontology.","title":"The Incunabula Ontology"},{"location":"01-introduction/example-project/#properties","text":"All the content produced by a Knora project must be stored in Knora resources (see incunabula-resource-classes). Resources have properties that point to different parts of their contents; for example, the incunabula project contains books, which have properties like title . Every property that poitns to a Knora value must be a subproperty of knora-base:hasValue , and every property that points to another Knora resource must be a subproperty of knora-base:hasLinkTo . Here is the definition of the incunabula:title property: :title rdf:type owl:ObjectProperty ; rdfs:subPropertyOf knora-base:hasValue, dcterms:title ; rdfs:label \"Titel\"@de , \"Titre\"@fr , \"Titolo\"@it , \"Title\"@en ; knora-base:subjectClassConstraint :book ; knora-base:objectClassConstraint knora-base:TextValue ; salsah-gui:guiElement salsah-gui:SimpleText ; salsah-gui:guiAttribute \"size=80\" , \"maxlength=255\" . The definition of incunabula:title consists of a list of triples, all of which have :title as their subject. To avoid repeating :title for each triple, Turtle syntax allows us to use a semicolon ( ; ) to separate triples that have the same subject. Moreover, some triples also have the same predicate; a comma ( , ) is used to avoid repeating the predicate. The definition of :title says: rdf:type owl:ObjectProperty : It is an owl:ObjectProperty . There are two kinds of OWL properties: object properties and datatype properties. Object properties point to objects, which have IRIs and can have their own properties. Datatype properties point to literal values, such as strings and integers. rdfs:subPropertyOf knora-base:hasValue, dcterms:title : It is a subproperty of knora-base:hasValue and dcterms:title . Since the objects of this property will be Knora values, it must be a subproperty of knora-base:hasValue . To facilitate searches, we have also chosen to make it a subproperty of dcterms:title . In the Knora API v2, if you do a search for resources that have a certain dcterms:title , and there is a resource with a matching incunabula:title , the search results could include that resource. rdfs:label \"Titel\"@de , etc.: It has the specified labels in various languages. These are needed, for example, by user interfaces, to prompt the user to enter a value. knora-base:subjectClassConstraint :book : The subject of the property must be an incunabula:book . knora-base:objectClassConstraint knora-base:TextValue : The object of this property must be a knora-base:TextValue (which is a subclass of knora-base:Value ). salsah-gui:guiElement salsah-gui:SimpleText : When SALSAH asks a user to enter a value for this property, it should use a simple text field. salsah-gui:guiAttribute \"size=80\" , \"maxlength=255\" : The SALSAH text field for entering a value for this property should be 80 characters wide, and should accept at most 255 characters. The incunabula ontology contains several other property definitions that are basically similar. Note that different subclasses of Value are used. For example, incunabula:pubdate , which represents the publication date of a book, points to a knora-base:DateValue . The DateValue class stores a date range, with a specified degree of precision and a preferred calendar system for display. A property can point to a Knora resource instead of to a Knora value. For example, in the incunabula ontology, there are resources representing pages and books, and each page is part of some book. This relationship is expressed using the property incunabula:partOf : :partOf rdf:type owl:ObjectProperty ; rdfs:subPropertyOf knora-base:isPartOf ; rdfs:label \"ist ein Teil von\"@de , \"est un part de\"@fr , \"e una parte di\"@it , \"is a part of\"@en ; rdfs:comment \"\"\"Diese Property bezeichnet eine Verbindung zu einer anderen Resource, in dem ausgesagt wird, dass die vorliegende Resource ein integraler Teil der anderen Resource ist. Zum Beispiel ist eine Buchseite ein integraler Bestandteil genau eines Buches.\"\"\"@de ; knora-base:subjectClassConstraint :page ; knora-base:objectClassConstraint :book ; salsah-gui:guiElement salsah-gui:Searchbox . The key things to notice here are: rdfs:subPropertyOf knora-base:isPartOf : The Knora base ontology provides a generic isPartOf property to express part-whole relationships. Like many properties defined in knora-base , a project cannot use knora-base:isPartOf directly, but must make a subproperty such as incunabula:partOf . It is important to note that knora-base:isPartOf is a subproperty of knora-base:hasLinkTo . Any property that points to a knora-base:Resource must be a subproperty of knora-base:hasLinkTo . In Knora terminology, such a property is called a link property . knora-base:objectClassConstraint :book : The object of this property must be a member of the class incunabula:book , which, as we will see below, is a subclass of knora-base:Resource . salsah-gui:guiElement salsah-gui:Searchbox : When SALSAH prompts a user to select the book that a page is part of, it should provide a search box enabling the user to find the desired book. Because incunabula:partOf is a link property, it must always accompanied by a link value property , which enables Knora to store metadata about each link that is created with the link property. This metadata includes the date and time when the link was created, its owner, the permissions it grants, and whether it has been deleted. Storing this metadata allows Knora to authorise users to see or modify the link, as well as to query a previous state of a repository in which a deleted link had not yet been deleted. (The ability to query previous states of a repository is planned for Knora API version 2.) The name of a link property and its link value property must be related by the following naming convention: to determine the name of the link value property, add the word Value to the name of the link property. Hence, the incunabula ontology defines the property partOfValue : :partOfValue rdf:type owl:ObjectProperty ; rdfs:subPropertyOf knora-base:isPartOfValue ; knora-base:subjectClassConstraint :page ; knora-base:objectClassConstraint knora-base:LinkValue . As a link value property, incunabula:partOfValue must point to a knora-base:LinkValue . The LinkValue class is an RDF reification of a triple (in this case, the triple that links a page to a book). For more details about this, see knora-base-linkvalue. Note that the property incunabula:hasAuthor points to a knora-base:TextValue , because the incunabula project represents authors simply by their names. A more complex project could represent each author as a resource, in which case incunabula:hasAuthor would need to be a subproperty of knora-base:hasLinkTo .","title":"Properties"},{"location":"01-introduction/example-project/#resource-classes","text":"The two main resource classes in the incunabula ontology are book and page . Here is incunabula:book : :book rdf:type owl:Class ; rdfs:subClassOf knora-base:Resource , [ rdf:type owl:Restriction ; owl:onProperty :title ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :hasAuthor ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :publisher ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"3\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :publoc ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"4\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :pubdate ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :location ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"6\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :url ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"7\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :description ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :physical_desc ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"9\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :note ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :citation ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :book_comment ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"12\"^^xsd:nonNegativeInteger ] ; knora-base:resourceIcon \"book.gif\" ; rdfs:label \"Buch\"@de , \"Livre\"@fr , \"Libro\"@it , \"Book\"@en ; rdfs:comment \"\"\"Diese Resource-Klasse beschreibt ein Buch\"\"\"@de . Like every Knora resource class, incunabula:book is a subclass of knora-base:Resource . It is also a subclass of a number of other classes of type owl:Restriction , which are defined in square brackets, using Turtle's syntax for anonymous blank nodes. Each owl:Restriction specifies a cardinality for a property that is allowed in resources of type incunabula:book . A cardinality is indeed a kind of restriction: it means that a resource of this type may have, or must have, a certain number of instances of the specified property. For example, incunabula:book has cardinalities saying that a book must have at least one title and at most one publication date. In the Knora API version 1, the word 'occurrence' is used instead of 'cardinality'. The OWL cardinalities supported by Knora are described in OWL Cardinalities . Note that incunabula:book specifies a cardinality of owl:minCardinality 0 on the property incunabula:hasAuthor . At first glance, this might seem as if it serves no purpose, since it says that the property is optional and can have any number of instances. You may be wondering whether this cardinality could simply be omitted from the definition of incunabula:book . However, Knora requires every property of a resource to have some cardinality in the resource's class. This is because Knora uses the cardinalities to determine which properties are possible for instances of the class, and the Knora API relies on this information. If there was no cardinality for incunabula:hasAuthor , Knora would not allow a book to have an author. Each owl:Restriction specifying a cardinality can include the predicate salsah-gui:guiOrder , which tells the SALSAH GUI the order the properties should be displayed in. Here is the definition of incunabula:page : :page rdf:type owl:Class ; rdfs:subClassOf knora-base:StillImageRepresentation , [ rdf:type owl:Restriction ; owl:onProperty :pagenum ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :partOfValue ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :partOf ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :seqnum ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"3\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :description ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :citation ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :page_comment ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"6\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :origname ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"7\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :hasLeftSidebandValue ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :hasLeftSideband ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :hasRightSidebandValue ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"11\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :hasRightSideband ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"11\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty :transcription ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ; salsah-gui:guiOrder \"12\"^^xsd:nonNegativeInteger ] ; knora-base:resourceIcon \"page.gif\" ; rdfs:label \"Seite\"@de , \"Page\"@fr , \"Page\"@en ; rdfs:comment \"\"\"Eine Seite ist ein Teil eines Buchs\"\"\"@de , \"\"\"Une page est une partie d'un livre\"\"\"@fr , \"\"\"A page is a part of a book\"\"\"@en . The incunabula:page class is a subclass of knora-base:StillImageRepresentation , which is a subclass of knora-base:Representation , which is a subclass of knora-base:Resource . The class knora-base:Representation is used for resources that contain metadata about files stored by Knora. Each It has different subclasses that can hold different types of files, including still images, audio, and video files. A given Representation can store metadata about several different files, as long as they are of the same type and are semantically equivalent, e.g. are different versions of the same image with different colorspaces, so that coordinates in one file will work in the other files. In Knora, a subclass inherits the cardinalities defined in its superclasses. Let's look at the class hierarchy of incunabula:page , starting with knora-base:Representation : :Representation rdf:type owl:Class ; rdfs:subClassOf :Resource , [ rdf:type owl:Restriction ; owl:onProperty :hasFileValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:comment \"A resource that can store one or more FileValues\"@en . This says that a Representation must have at least one instance of the property hasFileValue , which is defined like this: :hasFileValue rdf:type owl:ObjectProperty ; rdfs:subPropertyOf :hasValue ; :subjectClassConstraint :Representation ; :objectClassConstraint :FileValue . The subject of hasFileValue must be a Representation , and its object must be a FileValue . There are different subclasses of FileValue for different kinds of files, but we'll skip the details here. This is the definition of knora-base:StillImageRepresentation : :StillImageRepresentation rdf:type owl:Class ; rdfs:subClassOf :Representation , [ rdf:type owl:Restriction ; owl:onProperty :hasStillImageFileValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:comment \"A resource that can contain two-dimensional still image files\"@en . It must have at least one instance of the property hasStillImageFileValue , which is defined as follows: :hasStillImageFileValue rdf:type owl:ObjectProperty ; rdfs:subPropertyOf :hasFileValue ; :subjectClassConstraint :StillImageRepresentation ; :objectClassConstraint :StillImageFileValue . Because hasStillImageFileValue is a subproperty of hasFileValue , the cardinality on hasStillImageFileValue , defined in the subclass StillImageRepresentation , overrides the cardinality on hasFileValue , defined in the superclass Representation . In other words, the more general cardinality in the superclass is replaced by a more specific cardinality in the base class. Since incunabula:page is a subclass of StillImageRepresentation , it inherits the cardinality on hasStillImageFileValue . As a result, a page must have at least one image file attached to it. Here's another example of cardinality inheritance. The class knora-base:Resource has a cardinality for knora-base:seqnum . The idea is that resources of any type could be arranged in some sort of sequence. As we saw above, incunabula:page is a subclass of knora-base:Resource . But incunabula:page has its own cardinality for incunabula:seqnum , which is a subproperty of knora-base:seqnum . Once again, the subclass's cardinality on the subproperty replaces the superclass's cardinality on the superproperty: a page is allowed to have an incunabula:seqnum , but it is not allowed to have a knora-base:seqnum .","title":"Resource Classes"},{"location":"01-introduction/standoff-rdf/","text":"Standoff/RDF Text Markup Standoff markup is text markup that is stored separately from the content it describes. Knora's Standoff/RDF markup stores content as a simple Unicode string, and represents markup separately as RDF data. This approach has some advantages over commonly used markup systems such as XML: First, XML and other hierarchical markup systems assume that a document is a hierarchy, and have difficulty representing non-hierarchical structures or multiple overlapping hierarchies. Standoff markup can easily represent these structures. Second, markup languages are typically designed to be used in text files. But there is no standard system for searching and linking together many different text files containing markup. It is possible to do this in a non-standard way by using an XML database such as eXist , but this still does not allow for queries that include text as well as non-textual data not stored in XML. By storing markup as RDF, Knora can search for markup structures in the same way that it searches for any RDF data structure. This makes it possible to do searches that combine text-related criteria with other sorts of criteria. For example, if persons and events are represented as Knora resources, and texts are represented in Standoff/RDF, a text can contain tags representing links to persons or events. You could then search for a text that mentions a person who lived in the same city as another person who is the author of a text that mentions an event that occurred during a certain time period. In Knora's Standoff/RDF, a tag is an RDF entity that is linked to a text value . Each tag points to a substring of the text, and has semantic properties of its own. You can define your own tag classes in your ontology by making subclasses of knora-base:StandoffTag , and attach your own properties to them. You can then search for those properties using Knora's search language, Gravsearch . The built-in knora-base and standoff ontologies provide some basic tags that can be reused or extended. These include tags that represent Knora data types. For example, knora-base:StandoffDateTag represents a date in exactly the same way as a Knora date value , i.e. as a calendar-independent astronomical date. You can use this tag as-is, or extend it by making a subclass, to represent dates in texts. Gravsearch includes built-in functionality for searching for these data type tags. For example, you can search for text containing a date that falls within a certain date range . Knora's APIs support automatic conversion between XML and Standoff/RDF. To make this work, Standoff/RDF stores the order of tags and their hierarchical relationships. You must define an XML-to-Standoff Mapping for your standoff tag classes and properties. Then you can import an XML document into Knora, which will store it as Standoff/RDF. The text and markup can then be searched using Gravsearch. When you retrieve the document, Knora converts it back to the original XML. To represent overlapping or non-hierarchical markup in exported and imported XML, Knora supports CLIX tags. Future plans for Standoff/RDF include: Creation and retrieval of standoff markup as such via the Knora API, without using XML as an input/output format. A user interface for editing standoff markup. The ability to create resources that cite particular standoff tags in other resources.","title":"Standoff/RDF Text Markup"},{"location":"01-introduction/standoff-rdf/#standoffrdf-text-markup","text":"Standoff markup is text markup that is stored separately from the content it describes. Knora's Standoff/RDF markup stores content as a simple Unicode string, and represents markup separately as RDF data. This approach has some advantages over commonly used markup systems such as XML: First, XML and other hierarchical markup systems assume that a document is a hierarchy, and have difficulty representing non-hierarchical structures or multiple overlapping hierarchies. Standoff markup can easily represent these structures. Second, markup languages are typically designed to be used in text files. But there is no standard system for searching and linking together many different text files containing markup. It is possible to do this in a non-standard way by using an XML database such as eXist , but this still does not allow for queries that include text as well as non-textual data not stored in XML. By storing markup as RDF, Knora can search for markup structures in the same way that it searches for any RDF data structure. This makes it possible to do searches that combine text-related criteria with other sorts of criteria. For example, if persons and events are represented as Knora resources, and texts are represented in Standoff/RDF, a text can contain tags representing links to persons or events. You could then search for a text that mentions a person who lived in the same city as another person who is the author of a text that mentions an event that occurred during a certain time period. In Knora's Standoff/RDF, a tag is an RDF entity that is linked to a text value . Each tag points to a substring of the text, and has semantic properties of its own. You can define your own tag classes in your ontology by making subclasses of knora-base:StandoffTag , and attach your own properties to them. You can then search for those properties using Knora's search language, Gravsearch . The built-in knora-base and standoff ontologies provide some basic tags that can be reused or extended. These include tags that represent Knora data types. For example, knora-base:StandoffDateTag represents a date in exactly the same way as a Knora date value , i.e. as a calendar-independent astronomical date. You can use this tag as-is, or extend it by making a subclass, to represent dates in texts. Gravsearch includes built-in functionality for searching for these data type tags. For example, you can search for text containing a date that falls within a certain date range . Knora's APIs support automatic conversion between XML and Standoff/RDF. To make this work, Standoff/RDF stores the order of tags and their hierarchical relationships. You must define an XML-to-Standoff Mapping for your standoff tag classes and properties. Then you can import an XML document into Knora, which will store it as Standoff/RDF. The text and markup can then be searched using Gravsearch. When you retrieve the document, Knora converts it back to the original XML. To represent overlapping or non-hierarchical markup in exported and imported XML, Knora supports CLIX tags. Future plans for Standoff/RDF include: Creation and retrieval of standoff markup as such via the Knora API, without using XML as an input/output format. A user interface for editing standoff markup. The ability to create resources that cite particular standoff tags in other resources.","title":"Standoff/RDF Text Markup"},{"location":"01-introduction/what-is-knora/","text":"What Is Knora? Knora (Knowledge Organization, Representation, and Annotation) is a a content management system for the long-term preservation and reuse of humanities data. It is designed to accommodate data with a complex internal structure, including data that could be stored in relational databases. Knora aims to solve key problems in the long-term preservation and reuse of humanities data: First, traditional archives preserve data, but do not facilitate reuse. Typically, only metadata can be searched, not the data itself. You have to first identify an information package that might be of interest, then download it, and only then can you find out what's really in it. This is time-consuming, and makes it impractical to reuse data from many different sources. Knora solves this problem by keeping the data alive. You can query all the data in a Knora repository, not just the metadata. You can import thousands of databases into Knora, and run queries that search through all of them at once. Another problem is that researchers use a multitude of different data formats, many of which are proprietary and quickly become obsolete. It is not practical to maintain all the programs that were used to create and read old data files, or even all the operating systems that these programs ran on. Instead of preserving all these data formats, Knora supports the conversion of all sorts of data to a small number of formats that are suitable for long-term preservation, and that maintain the data's meaning and structure: Non-binary data is stored as RDF , in a dedicated database called a triplestore. RDF is an open, vendor-independent standard that can express any data structure. Binary media files (images, audio, and video) are converted to a few specialised archival file formats and stored by Sipi , with metadata stored in the triplestore. Knora then makes this data available for reuse via its generic, standards-based application programming interfaces (APIs). A virtual research environment (VRE) can then use these APIs to search, link together, and add to data from different research projects in a unified way. Humanities-Focused Data Storage Each project creates its own data model (or ontology ), describing the types of items it wishes to store, using basic data types defined in Knora's base ontology . This gives projects the freedom to describe their data in a way that makes sense to them, while allowing Knora to support searching and linking across projects. Knora has built-in support for data structures that are commonly needed in humanities data, and that present unique challenges for any type of database storage. Calendar-Independent Dates In the humanities, a date could be based on any sort of calendar (e.g. Gregorian, Julian, Islamic, or Hebrew). Knora stores dates using a calendar-independent, astronomical representation, and converts between calendars as needed. This makes it possible to search for a date in one calendar, and get search results in other calendars. Flexible, Searchable Text Markup Commonly used text markup systems, such as TEI/XML , have to represent a text as a hierarchy, and therefore have trouble supporting overlapping markup. Knora supports Standoff/RDF markup : the markup is stored as RDF data, separately from the text, allowing for overlapping markup. Knora's RDF-based standoff is designed to support the needs of complex digital critical editions. Knora can import any XML document (including TEI/XML) for storage as standoff/RDF, and can regenerate the original XML document at any time. Powerful Searches Knora's API provides a search language, Gravsearch , that is designed to meet the needs of humanities researchers. Gravsearch supports Knora's humanites-focused data structures, including calendar-independent dates and standoff markup, as well as fast full-text searches. This allows searches to combine text-related criteria with any other criteria. For example, you could search for a text that contains a certain word and also mentions a person who lived in the same city as another person who is the author of a text that mentions an event that occurred during a certain time period. Access Control The RDF standards do not include any concept of permissions. Knora's permission system allows project administrators and users to determine who can see or modify each item of data. Knora filters search results according to each user's permissions. Data History RDF does not have a concept of data history. Knora maintains all previous versions of each item of data. Ordinary searches return only the latest version, but you can obtain and cite an item as it was at any point in the past. Data Consistency RDF triplestores do not implement a standardised way of ensuring the consistency of data in a repository. Knora ensures that all data is consistent, conforms the project-specific data models, and meets Knora's minimum requirements for interoperability and reusability of data. Linked Open Data Knora supports publishing data online as as Linked Open Data , using open standards to allow interoperability between different repositories on the web. Build Your Own Application Knora can be used with a general-purpose, browser-based VRE called SALSAH . Using the Knora API and Knora-ui , a set of reusable user-interface components, you can also create your own VRE or project-specific web site.","title":"What is Knora?"},{"location":"01-introduction/what-is-knora/#what-is-knora","text":"Knora (Knowledge Organization, Representation, and Annotation) is a a content management system for the long-term preservation and reuse of humanities data. It is designed to accommodate data with a complex internal structure, including data that could be stored in relational databases. Knora aims to solve key problems in the long-term preservation and reuse of humanities data: First, traditional archives preserve data, but do not facilitate reuse. Typically, only metadata can be searched, not the data itself. You have to first identify an information package that might be of interest, then download it, and only then can you find out what's really in it. This is time-consuming, and makes it impractical to reuse data from many different sources. Knora solves this problem by keeping the data alive. You can query all the data in a Knora repository, not just the metadata. You can import thousands of databases into Knora, and run queries that search through all of them at once. Another problem is that researchers use a multitude of different data formats, many of which are proprietary and quickly become obsolete. It is not practical to maintain all the programs that were used to create and read old data files, or even all the operating systems that these programs ran on. Instead of preserving all these data formats, Knora supports the conversion of all sorts of data to a small number of formats that are suitable for long-term preservation, and that maintain the data's meaning and structure: Non-binary data is stored as RDF , in a dedicated database called a triplestore. RDF is an open, vendor-independent standard that can express any data structure. Binary media files (images, audio, and video) are converted to a few specialised archival file formats and stored by Sipi , with metadata stored in the triplestore. Knora then makes this data available for reuse via its generic, standards-based application programming interfaces (APIs). A virtual research environment (VRE) can then use these APIs to search, link together, and add to data from different research projects in a unified way.","title":"What Is Knora?"},{"location":"01-introduction/what-is-knora/#humanities-focused-data-storage","text":"Each project creates its own data model (or ontology ), describing the types of items it wishes to store, using basic data types defined in Knora's base ontology . This gives projects the freedom to describe their data in a way that makes sense to them, while allowing Knora to support searching and linking across projects. Knora has built-in support for data structures that are commonly needed in humanities data, and that present unique challenges for any type of database storage.","title":"Humanities-Focused Data Storage"},{"location":"01-introduction/what-is-knora/#calendar-independent-dates","text":"In the humanities, a date could be based on any sort of calendar (e.g. Gregorian, Julian, Islamic, or Hebrew). Knora stores dates using a calendar-independent, astronomical representation, and converts between calendars as needed. This makes it possible to search for a date in one calendar, and get search results in other calendars.","title":"Calendar-Independent Dates"},{"location":"01-introduction/what-is-knora/#flexible-searchable-text-markup","text":"Commonly used text markup systems, such as TEI/XML , have to represent a text as a hierarchy, and therefore have trouble supporting overlapping markup. Knora supports Standoff/RDF markup : the markup is stored as RDF data, separately from the text, allowing for overlapping markup. Knora's RDF-based standoff is designed to support the needs of complex digital critical editions. Knora can import any XML document (including TEI/XML) for storage as standoff/RDF, and can regenerate the original XML document at any time.","title":"Flexible, Searchable Text Markup"},{"location":"01-introduction/what-is-knora/#powerful-searches","text":"Knora's API provides a search language, Gravsearch , that is designed to meet the needs of humanities researchers. Gravsearch supports Knora's humanites-focused data structures, including calendar-independent dates and standoff markup, as well as fast full-text searches. This allows searches to combine text-related criteria with any other criteria. For example, you could search for a text that contains a certain word and also mentions a person who lived in the same city as another person who is the author of a text that mentions an event that occurred during a certain time period.","title":"Powerful Searches"},{"location":"01-introduction/what-is-knora/#access-control","text":"The RDF standards do not include any concept of permissions. Knora's permission system allows project administrators and users to determine who can see or modify each item of data. Knora filters search results according to each user's permissions.","title":"Access Control"},{"location":"01-introduction/what-is-knora/#data-history","text":"RDF does not have a concept of data history. Knora maintains all previous versions of each item of data. Ordinary searches return only the latest version, but you can obtain and cite an item as it was at any point in the past.","title":"Data History"},{"location":"01-introduction/what-is-knora/#data-consistency","text":"RDF triplestores do not implement a standardised way of ensuring the consistency of data in a repository. Knora ensures that all data is consistent, conforms the project-specific data models, and meets Knora's minimum requirements for interoperability and reusability of data.","title":"Data Consistency"},{"location":"01-introduction/what-is-knora/#linked-open-data","text":"Knora supports publishing data online as as Linked Open Data , using open standards to allow interoperability between different repositories on the web.","title":"Linked Open Data"},{"location":"01-introduction/what-is-knora/#build-your-own-application","text":"Knora can be used with a general-purpose, browser-based VRE called SALSAH . Using the Knora API and Knora-ui , a set of reusable user-interface components, you can also create your own VRE or project-specific web site.","title":"Build Your Own Application"}]}